# Inhaltsverzeichnis


### Requirement dialog
Um einen ersten Überblick über potenzielle Benutzer und Interessenten an unserem System zu gewinnen, haben wir mit einer klassischen Stakeholderanalyse [(Quelle)](Von wem ist die erfunden?) gestartet, die einen ersten Eindruck über mögliche Interessensgruppen innerhalb der Anwendungsdomäne vermitteln soll [(Stakeholderanalyse)](Tabelle im Anhang).
Konkret lassen sich daraus folgende Stakeholder erschließen:

___
hier Stakeholernamen eintragen
___

In einem ersten Gespräch mit potenziellen, aktiven Benutzern des Systems innerhalb der Anwendungsdomäne, wurde festgehalten welche Erfordernisse und Erwartungen diese an solch einem System haben. Diese dazugewonenen Informationen wurden in der Stakeholderanalyse ergänzt [Anhang?](verweis Erfordernisse) und im späteren Verlauf in den Entwicklungsprozess eingebunden.


### Anforderungen
Anhand der identifizierten Erfordernisse und Bedürfnisse der Benutzer aus dem *Requirement Dialog* [Textverweis](auf textstelle) konnten wir erste Anforderungen an das System ableiten [Verweis](Anhang Anforderungen). Diese wurden unterteilt in Funktionale- (Selbstständige Systemaktivität, Benutzerinteraktion, Schnittstellenanforderungen),  Qualitative-  und Organisatorische Anforderungen.   
Die identifizierten Anforderungen dienten uns als Leitfaden und Überprüfung der Zielerreichung unseres Projektes.


### Vorgehensmodell
Nach Spezifikation des Nutzungskontextes und der Anwendungsdomäne sind wir zu dem Entschlus gekommen das in unserem System die Nutzung im Vordergrund steht. Das vorrangige Ziel des Systems ist es dem Benutzer einen Vorschlag für einen freien Raum in seiner Nähe zu liefern, den er bei Bedarf reservieren und buchen kann was es zu einem nützlichen Werkzeug macht. Dabei ist weniger auf persönliche Benutzereigenschaften Rücksicht zu nehmen, sondern vielmehr ein Werkzeug zu schaffen, dass die gestellte Aufgabe des Benutzers schnell und unkompliziert zu lösen vermag. Daraus folgend ist für unser Projekt eher ein "user involved" als ein "user-centred" Vorgehensmodell relevant.
Aus diesem Grund haben wir uns für das __*Usage-centred design* (1996) von Lockwood und Constantine__[Quelle](Buchquelle) entschieden. Dieses Vorgehensmodell beinhaltet genau die von uns geforderten Eigenschaften und Methoden die zur Erstellung eines Systems benötigt werden, bei dem die Nutzung im Vordergrund steht. Zusätzlich bietet es die entscheidende Möglichkeit der Skalierbarkeit von Methoden und Vorgehensweisen, welche wir für unser eher kleines Projekt anwenden werden. Im folgenden werden die angewandten Methoden der einzelnen Prozesschritte kurz begründet erläutert, und im Anschluss angewand.
___
begründet Methoden ausschließen!!!
___


### Benutzermodellierung
Das "usage-centred design" Vorgehen schlägt zur Benutzermodellierung die Erstellung von *user roles* [(Quelle)](Buchseite) und anschließenden *user role maps* [(Quelle)](Buchseite) vor. Um einen Überblick über Benutzergruppen, ihren Eigenschaften und ihren speziellen Erfordernissen an das System zu bekommen, halten wir diese Rollenaufteilung als sinnvolles Mittel um Bedürfnisse von Benutzergruppen darzustellen. Da sich aus den ersten Informationen des *Requirement dialog* schon Benutzergruppen mit unterschiedlichen Bedürfnissen ergeben haben, wurden diese in *user roles* modelliert. Im späteren Entwicklungsprozess sind Ergänzungen und Aktualisierungen vorgenommen worden. Folgende *user roles* wurden für dieses Projekt erarbeitet:
___
user roles - namen einfügen
___
Eine detaillierte, tabelarische Form der *role models* findet sich im [Anhang](verweis role models).



### Benutzungsmodellierung
Um im nächsten Schritt die Aufgaben der verschiedenen Benutzergruppen zu erschließen, haben wir unter Zuhilfenahme der identifizierten *user roles* ein Brainstorming durchgeführt, um einen ersten Überblick über mögliche benötigte Aufgaben bzw. Bedürfnisse der Benutzer zu bekommen [Verweis](Anhang Aufgaben_Brainstorming). Dabei sind wir auf die bereits vorhandenen Informationen aus dem *Requirement Dialog* und den irentifizierten Anforderungen eingegangen, und haben diese erweitert.
Da diese Aufgaben teilweise ungenau formulliert, bzw. noch Mehrdeutigkeiten zuließen, haben wir die gefundenen Aufgaben in *Essential Use Cases* formulliert, die die wichtigsten Bedürfnissen der Benutzer und die Reaktion des Systems auf diese Bedürfnisse wiederspiegeln [Verweis](Anhang Essential Use Cases). Unserer Meinung nach sind Use Cases ein valides und sinnvolles Mittel um eine Aufgaben-zentrierte Softwarelösung zu entwickeln.   
Um die erarbeiteten und benötigten Aufgaben evaluieren zu können, haben wir uns dazu entschloßen diese noch in der Form des *Concrete Use Cases* zu formulieren [Verweis](Anhang Concrete Use Cases). Diese Use Cases wurden von uns in einer narativen und verständlichen, in der Anwendungsdomäne befindlichen Spache verfasst, um sie in einem Evaluationsprozess potenziellen Benutzern vorzustellen. Das Feedback der Benutzer wurde dazu genutzt die Aufgaben zu überarbeiten und zu verbessern. 




















